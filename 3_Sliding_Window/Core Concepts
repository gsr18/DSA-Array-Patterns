ğŸ’¡ Core Idea (Analogy)

Imagine looking through a fixed-size window while walkingâ€”only the current view matters, and you slide it one step at a time.

Use a dynamic window (range) on the array, typically defined by two pointers (start and end), to evaluate subarrays efficiently in O(n) time.

ğŸ¯ When to Use (How to Recognize It)

--> You need to find maximum/minimum sum, longest/shortest subarray meeting a condition
--> Works when elements are positive, or the sum/condition monotonically changes as window grows/shrinks
--> Brute force does nested loops â†’ can optimize by adjusting start/end not restarting

ğŸ”§ 3. General Strategy (How to Use It)
Initialize start = 0, end = 0, currentSum = 0
Expand end to include new elements
While window invalid:
  Shrink from start
Check or record results
Repeat until end reaches end

ğŸ” 4. How It Works (Step-by-step)

--> Grow window from the right until condition is violated or limit reached
--> Shrink window from the left to restore condition
--> Track best answer (sum, length, count, max/min) at each valid window

No nested restartsâ€”efficient O(n) total movement

ğŸ“Š Visual Patterns
ğŸ”¸ Fixed-size Window
[startâ†’      â†end]
[3, 1, 4, 2, 5]  (size = k)

ğŸ”¸ Variable-size Window
[startâ†’      â†end]
[2, 1, 3, 5, 2, 1]
  expand â†’ â†’ â†’ â†’ then shrink when sum > target

ğŸ§¾ Final Trigger (Write in bold):

â€œWhen you need to find or optimize a subarray with moving edge constraintsâ€”Sliding Window (grow/shrink) offers O(n) power with two pointers.â€
