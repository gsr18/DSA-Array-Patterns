💡 Core Idea (Analogy)

Imagine looking through a fixed-size window while walking—only the current view matters, and you slide it one step at a time.

Use a dynamic window (range) on the array, typically defined by two pointers (start and end), to evaluate subarrays efficiently in O(n) time.

🎯 When to Use (How to Recognize It)

--> You need to find maximum/minimum sum, longest/shortest subarray meeting a condition
--> Works when elements are positive, or the sum/condition monotonically changes as window grows/shrinks
--> Brute force does nested loops → can optimize by adjusting start/end not restarting

🔧 3. General Strategy (How to Use It)
Initialize start = 0, end = 0, currentSum = 0
Expand end to include new elements
While window invalid:
  Shrink from start
Check or record results
Repeat until end reaches end

🔎 4. How It Works (Step-by-step)

--> Grow window from the right until condition is violated or limit reached
--> Shrink window from the left to restore condition
--> Track best answer (sum, length, count, max/min) at each valid window

No nested restarts—efficient O(n) total movement

📊 Visual Patterns
🔸 Fixed-size Window
[start→      ←end]
[3, 1, 4, 2, 5]  (size = k)

🔸 Variable-size Window
[start→      ←end]
[2, 1, 3, 5, 2, 1]
  expand → → → → then shrink when sum > target

🧾 Final Trigger (Write in bold):

“When you need to find or optimize a subarray with moving edge constraints—Sliding Window (grow/shrink) offers O(n) power with two pointers.”
