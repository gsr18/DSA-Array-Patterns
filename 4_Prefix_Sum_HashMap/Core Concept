ğŸ’¡ Core Idea (Analogy)

Imagine walking on a path and keeping a diary of total steps taken so far (prefix sum). At every step, you check:
â€œHave I walked this exact number of extra steps before?â€
If yes, the subpath between those two points has a special property.

ğŸ¯ When to Use (How to Recognize It)

--> When the problem talks about subarray sum (especially with negatives or zeros involved)
--> You need to count or find the longest subarray satisfying some condition (e.g. sum = K, XOR = K)
--> Brute force is O(nÂ²), this pattern reduces it to O(n) using HashMap to remember prefixes

ğŸ”§ General Strategy
1. Keep a running prefix (sum or XOR)
2. Use a HashMap to store {prefix: first index}
3. At each step, check if (prefix - target) exists â†’ subarray found!
4. If prefix already seen, update result

ğŸ” How It Works (Step-by-step)

--> Calculate a running prefix sum
--> Store the first index where each prefix value occurred
--> At each index i, check if (currentPrefix - K) exists
--> If yes â†’ subarray from map[currentPrefix - K] + 1 to i has sum K
--> Keep track of max length, count, etc., as needed

ğŸ“Š Visual Representation

Letâ€™s say we have:

A = [1, 2, 3, -2, 5], K = 5
Prefix Sum = [1, 3, 6, 4, 9]
Check if prefix - K (e.g., 6 - 5 = 1) existed before.
If yes â†’ subarray found!

ğŸ”š Final Trigger:

"When you need to count or find subarrays with specific sum or XOR, and negatives exist â€” use the powerful combo: Prefix + HashMap.â€
