ğŸ’¡ Core Idea (Ultimate Analogy + Intuition):

â€œTry everything, no shortcuts.â€
Like searching for your friend by opening every door in a hotel hallway. You have no info about where they are, so you brute-force the search.

This pattern is your starting ground.
Itâ€™s slow, but itâ€™s guaranteed to cover all cases.

You're not being clever â€” you're being complete.

ğŸ§  When to Use This Pattern

Use Linear Scan or Brute Force when:

You are checking all values (for max, min, condition, etc.)

The array is unsorted / unstructured

You are not told about:

Sorted order

Duplicates or uniqueness

Constraints you can exploit

You need to try all combinations or choices

You are building your base logic before optimizing

ğŸ§© How It Works (Backed by Visual Algorithms + MIT Intuition)
Type	Loop(s)	Description
Single Scan	1 loop	Check each element independently
Nested Scan (pairs)	2 loops	For each i, check j > i â€” for pairs
Triple Nested	3 loops	Used for checking triplets (e.g. triplet sum)
Recursive Brute Force	Recursion	Try all paths (used in backtracking baseline)

ğŸ’¡ It checks everything manually and guarantees correctness at the cost of performance.

ğŸ“Š Visual Pattern
ğŸ”¹ Single Scan
    i â†’
[ 3, 8, 1, 9, 2 ]

Action: Compare each to current max/min

ğŸ”¹ Nested Pair Scan
    i â†’        j â†’
[ 1, 2, 3, 4 ]

(1,2), (1,3), (1,4)  
(2,3), (2,4)  
(3,4)

â± Time & Space Complexity
Case	Time	Space
Single element scan	O(n)	O(1)
Pair check (nested)	O(nÂ²)	O(1)
Triplet check	O(nÂ³)	O(1)
Recursive brute force	O(2â¿)	Stack

ğŸ§  Use when n is small (n â‰¤ 1000) or as a base to validate better logic
