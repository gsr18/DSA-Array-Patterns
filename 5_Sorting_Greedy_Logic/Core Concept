ğŸ’¡ Core Idea (Analogy)

Like sorting your books by height before arranging them so tallest are visibleâ€”that sorting sets a clear order, then your greedy logic picks the best next move.

We sort items to impose a meaningful order, making it easy to make local optimal choices (greedy decisions) in one linear sweep.

ğŸ¯ When to Use (How to Recognize It)

--> You need to reorder items and pick the best ones under constraints.
--> Keywords: sort 0s,1s,2s; merge intervals; next permutation; leaders; longest consecutive.
--> Brute force is messyâ€”sorting first organizes data, then a simple pass suffices.

ğŸ”§ 3. General Strategy
1. SORT the array/items by key (e.g., value, color, boundary)
2. Apply a single pass with GREEDY decisions:
   - Partition, merge, swap, collect as needed


Sorting lets us rely on a consistent structure, and greedy logic helps us extract the optimal solution efficiently in a single pass.

ğŸ” 4. How It Works (Stepâ€‘byâ€‘step)

--> Sort key attribute(s): value, color, interval start, permutation order.
--> Make a single pass in that order:
--> For Dutch Flag: partition 0s/1s/2s
--> For Intervals: merge overlapping segments
--> For Next Permutation: perform specific in-place rearrangement
--> For leaders/consecutive sequence: identify based on sorted context
--> Each greedy decision is local, but sorting ensures those decisions combine into a global optimum or correct structure.

ğŸ“Š Visual Patterns
[0s | 1s | 2s]         Dutch flag pointers
###########
[ (start,end), ... ]   Merge if overlapping
###########
1 2 3 5 4              Next perm: swap and reverse

âš ï¸ Pitfalls

âŒ Sort keys must be chosen correctly (value, start, ratioâ€¦)
âŒ After greedy decision, watch for off-by-one or edge cases
âš ï¸ In-place merges require careful index management

ğŸ§¾ Final Trigger

â€œIf rearrangement or optimal selection is allowed, sort first, then apply greedy logic for a single efficient scan.â€
